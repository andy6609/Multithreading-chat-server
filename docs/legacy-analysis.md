Key Architectural Limitations Identified (Legacy Java)

기존 구현에서 확인한 핵심 구조적 한계는 다음과 같습니다.
	1.	공유 상태(Shared Mutable State) 중심의 서버 상태 관리
서버가 접속자 목록/유저리스트 등 핵심 상태를 공유 자료구조로 보유하고, 락으로 동기화하는 구조였습니다. 이 방식은 동시 접속자가 증가할수록 락 경합이 커지고, 상태 변경 흐름을 추적하기 어려워 안정성과 확장성 측면에서 한계가 있습니다.
	2.	Thread-per-Connection + 블로킹 I/O 모델의 확장성 제약
클라이언트 입력 처리에 블로킹 I/O가 사용되고, 연결당 스레드를 점유하는 형태라 동시 접속 규모가 커질수록 리소스 사용량(스레드/메모리)과 컨텍스트 스위칭 오버헤드가 구조적으로 증가합니다.
	3.	컴포넌트 간 직접 호출(Direct Invocation)로 인한 결합도 증가
메시지 브로드캐스트/전달이 “다른 컴포넌트의 메서드를 직접 호출”하는 방식에 가깝게 설계되어, 동시성 경계를 넘나드는 호출이 많아지고 동기화 복잡도가 증가합니다. 결과적으로 유지보수와 기능 확장이 어려워질 수 있습니다.
	4.	락 기반 동기화(Lock-based Synchronization) 의존
서버 핵심 로직이 synchronized 등 락 기반 제어에 의존해 동작하며, 규모가 커질수록 경합과 지연이 커질 수 있습니다. 또한 “어디서 락을 잡고 풀고 있는지”가 분산될수록 디버깅 난이도가 올라갑니다.
	5.	단일 책임이 과도하게 집중된 중앙집중형 구조(Centralized Coordinator)
연결 관리, 유저리스트 갱신, 메시지 라우팅 등 다양한 책임이 하나의 중심 컴포넌트에 몰리는 경향이 있어, 병목 지점이 생기기 쉽고 테스트/확장/변경에 취약해집니다.
